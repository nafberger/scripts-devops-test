# Azure DevOps Pipeline for ASP.NET Web Forms deployment to Azure VM
# Builds from GitHub repository and deploys to IIS on Azure VM
# Manual trigger only - no automatic builds

trigger: none

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'
  deploymentPath: 'C:\inetpub\wwwroot\SimpleWebFormsTest'

stages:
- stage: Build
  displayName: 'Build Application'
  jobs:
  - job: Build
    displayName: 'Build ASP.NET Web Forms'
    pool:
      vmImage: 'windows-latest'   # build on Microsoft-hosted agent
    steps:
    - checkout: self
      displayName: 'Checkout GitHub Repository'

    # Publish the Web Forms project output to the artifact folder
    - task: MSBuild@1
      displayName: 'Build & Publish Web Project'
      inputs:
        solution: '$(solution)'                    # better: point directly to your web .csproj
        platform: '$(buildPlatform)'
        configuration: '$(buildConfiguration)'
        msbuildArguments: >
          /p:DeployOnBuild=true
          /p:WebPublishMethod=FileSystem
          /p:DeleteExistingFiles=true
          /p:PrecompileBeforePublish=true
          /p:PackageAsSingleFile=false
          /p:PublishUrl=$(Build.ArtifactStagingDirectory)\WebApp

    # - task: CopyFiles@2
    #   displayName: 'Copy Web Files'
    #   inputs:
    #     SourceFolder: 'Web'
    #     Contents: |
    #       **/*.aspx
    #       **/*.aspx.cs
    #       **/*.config
    #       **/*.css
    #       **/*.js
    #       **/*.html
    #       **/*.htm
    #       bin/**
    #     TargetFolder: '$(Build.ArtifactStagingDirectory)/WebApp'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/WebApp'
        ArtifactName: 'WebApp'
        publishLocation: 'Container'

- stage: Deploy
  displayName: 'Deploy to Azure VM'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeployToVM
    displayName: 'Deploy to IIS on Azure VM'
    pool: {}                         # prevent default 'Azure Pipelines' pool
    environment:
      name: Production               # the Environment name
      resourceName: testvm           # EXACT VM resource name in that Environment
      resourceType: VirtualMachine
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: WebApp
            displayName: 'Download Build Artifacts'

          # Stop IIS application pool (use Windows PowerShell)
          - task: PowerShell@2
            displayName: 'Stop Application Pool'
            inputs:
              targetType: 'inline'
              pwsh: false
              script: |
                Import-Module WebAdministration
                if (Get-IISAppPool -Name "SimpleWebFormsTest" -ErrorAction SilentlyContinue) {
                  Stop-WebAppPool -Name "SimpleWebFormsTest"
                  Write-Host "Application pool stopped"
                } else {
                  Write-Host "Application pool does not exist, will be created during deployment"
                }

          # Copy files to IIS directory
          - task: CopyFiles@2
            displayName: 'Deploy to IIS Directory'
            inputs:
              SourceFolder: '$(Pipeline.Workspace)/WebApp'
              Contents: '**'
              TargetFolder: '$(deploymentPath)'
              OverWrite: true

          # Configure IIS App Pool and Site (use Windows PowerShell)
          - task: PowerShell@2
            displayName: 'Configure IIS Application Pool and Site'
            inputs:
              targetType: 'inline'
              pwsh: false
              script: |
                Import-Module WebAdministration

                if (-not (Get-IISAppPool -Name "SimpleWebFormsTest" -ErrorAction SilentlyContinue)) {
                  New-WebAppPool -Name "SimpleWebFormsTest"
                  Write-Host "Created application pool: SimpleWebFormsTest"
                }

                Set-ItemProperty -Path "IIS:\AppPools\SimpleWebFormsTest" -Name "managedRuntimeVersion" -Value "v4.0"
                Set-ItemProperty -Path "IIS:\AppPools\SimpleWebFormsTest" -Name "enable32BitAppOnWin64" -Value $false

                if (-not (Get-Website -Name "SimpleWebFormsTest" -ErrorAction SilentlyContinue)) {
                  New-Website -Name "SimpleWebFormsTest" -Port 8080 -PhysicalPath "$(deploymentPath)" -ApplicationPool "SimpleWebFormsTest"
                  Write-Host "Created website: SimpleWebFormsTest on port 8080"
                } else {
                  Set-ItemProperty -Path "IIS:\Sites\SimpleWebFormsTest" -Name "physicalPath" -Value "$(deploymentPath)"
                  Write-Host "Updated website path"
                }

                $acl = Get-Acl "$(deploymentPath)"
                $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("IIS_IUSRS","FullControl","ContainerInherit,ObjectInherit","None","Allow")
                $acl.SetAccessRule($rule)
                Set-Acl "$(deploymentPath)" $acl
                Write-Host "Set IIS_IUSRS permissions"

          # Start IIS application pool (use Windows PowerShell)
          - task: PowerShell@2
            displayName: 'Start Application Pool'
            inputs:
              targetType: 'inline'
              pwsh: false
              script: |
                Import-Module WebAdministration
                Start-WebAppPool -Name "SimpleWebFormsTest"
                Write-Host "Application pool started"

          # Health check (use Windows PowerShell)
          - task: PowerShell@2
            displayName: 'Health Check'
            inputs:
              targetType: 'inline'
              pwsh: false
              script: |
                Start-Sleep -Seconds 10
                try {
                  $response = Invoke-WebRequest -Uri "http://localhost:8080" -UseBasicParsing -TimeoutSec 30
                  if ($response.StatusCode -eq 200) {
                    Write-Host "✅ Deployment successful! Application is responding on port 8080"
                    Write-Host "Response status: $($response.StatusCode)"
                  } else {
                    Write-Warning "⚠️ Application responded with status: $($response.StatusCode)"
                  }
                } catch {
                  Write-Error "❌ Health check failed: $($_.Exception.Message)"
                  exit 1
                }
